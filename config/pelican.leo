<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="yen.20170108171605.1"><vh>@settings</vh>
<v t="yen.20170108171605.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="yen.20170108171605.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="yen.20170108171733.1"><vh>@path ../</vh>
<v t="leo.20180115150519.1"><vh>@edit index.html</vh></v>
<v t="yen.20170108171733.3"><vh>@edit README.md</vh></v>
<v t="yen.20170108171733.4"><vh>@edit .gitignore</vh></v>
<v t="leo.20170908162839.1"><vh>沒有 disqus 論壇</vh>
<v t="yen.20170108171733.2"><vh>@button local-blog</vh></v>
</v>
<v t="leo.20170908162904.1"><vh>有 disqus 論壇</vh>
<v t="leo.20170709224430.1"><vh>@button github-blog</vh></v>
</v>
<v t="yen.20170108171733.5"><vh>Pelican 設定</vh>
<v t="leo.20170709020600.1"><vh>共用</vh></v>
<v t="yen.20170108171733.7"><vh>@edit pelicanconf.py</vh></v>
<v t="leo.20170709015947.1"><vh>遠端</vh></v>
<v t="leo.20170709015955.1"><vh>@edit publishconf.py</vh></v>
<v t="leo.20170709015940.1"><vh>近端</vh></v>
<v t="yen.20170108171733.6"><vh>@edit local_publishconf.py</vh></v>
</v>
<v t="yen.20170224232341.1"><vh>編輯 template</vh>
<v t="leo.20180115093448.1"><vh>@path theme/attila/templates</vh>
<v t="leo.20180715212936.1"><vh>@edit article.html</vh></v>
<v t="leo.20180115093536.1"><vh>@edit base.html</vh></v>
<v t="leo.20180115093657.1"><vh>@edit search.html</vh></v>
<v t="leo.20180115093715.1"><vh>@edit archives.html</vh></v>
<v t="leo.20180715212745.1"><vh>@edit categories.html</vh></v>
<v t="leo.20180715212902.1"><vh>@edit index.html</vh></v>
<v t="leo.20180115093726.1"><vh>@path partials</vh>
<v t="leo.20180115093749.1"><vh>@edit navigation.html</vh></v>
</v>
<v t="leo.20180115142025.1"><vh>保留之前舊的設定檔案</vh></v>
</v>
<v t="yen.20170224232341.2"><vh>@path theme/pelican-bootstrap3_local/templates</vh>
<v t="yen.20170224232341.3"><vh>@edit base.html</vh></v>
</v>
<v t="leo.20170710015301.1"><vh>@path theme/pelican-bootstrap3/templates</vh>
<v t="leo.20170710015311.1"><vh>@edit search.html</vh></v>
<v t="leo.20170710095845.1"><vh>@edit base.html</vh></v>
<v t="leo.20170710101854.1"><vh>@edit article.html</vh></v>
</v>
</v>
<v t="leo.20170710015511.1"><vh>編輯 plugin</vh>
<v t="leo.20170710015523.1"><vh>@path plugin</vh>
<v t="leo.20170710015523.2"><vh>@path tipue_search</vh>
<v t="leo.20170710015523.3"><vh>@edit tipue_search.py</vh></v>
</v>
</v>
</v>
<v t="yen.20170108171733.71"><vh>@path markdown</vh>
<v t="yen.20170108171733.81"><vh>@path pages</vh>
<v t="yen.20170108171733.82"><vh>@edit pages_1.md</vh></v>
</v>
</v>
<v t="leo.20170710022054.1"><vh>可以另建節點存放 markdown 目錄下的 md 檔案</vh></v>
<v t="leo.20170710022041.1"><vh>@path markdown</vh>
<v t="leo.20180115115910.1"><vh>2020</vh>
<v t="leo.20200604214958.1"><vh>@clean MYDATA2.md</vh>
<v t="leo.20200604215030.1"><vh>227556342226589064</vh></v>
</v>
<v t="leo.20200604214910.1"><vh>@clean MYDATA1.md</vh>
<v t="leo.20200604215039.1"><vh>8605136594066136969</vh></v>
</v>
<v t="leo.20200604222242.1"><vh>@clean 50833102-1.md</vh></v>
<v t="leo.20200604222704.1"><vh>@clean 50833102-2.md</vh>
<v t="leo.20200604222739.1"><vh>194215135573871341</vh></v>
</v>
<v t="leo.20200605133612.1"><vh>@clean 50833102-3.md</vh>
<v t="leo.20200605164404.1"><vh>newHeadline</vh></v>
<v t="leo.20200605140138.1"><vh>8896516423278036060</vh></v>
</v>
<v t="leo.20200605145658.1"><vh>@clean 50833102-4.md</vh>
<v t="leo.20200605164006.1"><vh>newHeadline</vh></v>
<v t="leo.20200605151650.1"><vh>2811539222985720267</vh></v>
</v>
<v t="leo.20200605152629.1"><vh>@clean 50833102-5.md</vh></v>
<v t="leo.20200619231235.1"><vh>@clean 50833102-6.md</vh></v>
<v t="leo.20200619232357.1"><vh>@clean 50833102-7.md</vh>
<v t="leo.20200619233330.1"><vh>3684706627757311938</vh></v>
</v>
<v t="leo.20200619233415.1"><vh>@clean 50833102-8.md</vh></v>
<v t="leo.20200620093305.1"><vh>@clean 50833102-9.md</vh></v>
<v t="leo.20200620065914.1"><vh>newHeadline</vh></v>
</v>
</v>
<v t="yen.20170108171733.83"><vh>產生 .key 與 .crt 指令</vh></v>
</v>
<v t="yen.20170108171930.1"><vh>@button add_to_blogger</vh></v>
<v t="leo.20200605043111.1"><vh>@button edit_to_blogger</vh></v>
<v t="leo.20200605043055.1"><vh>@button https server</vh></v>
<v t="yen.20170108171939.1"><vh>@button ipv6 https server</vh></v>
</vnodes>
<tnodes>
<t tx="leo.20170709015940.1"></t>
<t tx="leo.20170709015947.1"></t>
<t tx="leo.20170709020600.1"></t>
<t tx="leo.20170709224430.1">@language python
import os

os.system("pelican markdown -o blog -s publishconf.py")
g.es("admin pelican Github 執行完畢")


</t>
<t tx="leo.20170710015301.1"></t>
<t tx="leo.20170710015511.1"></t>
<t tx="leo.20170710015523.1"></t>
<t tx="leo.20170710015523.2"></t>
<t tx="leo.20170710022041.1"></t>
<t tx="leo.20170710022054.1"></t>
<t tx="leo.20170908162839.1"></t>
<t tx="leo.20170908162904.1"></t>
<t tx="leo.20180115093448.1"></t>
<t tx="leo.20180115093726.1"></t>
<t tx="leo.20180115115910.1"></t>
<t tx="leo.20180115142025.1"></t>
<t tx="leo.20200604214910.1">@language md
---
Title: 2019 Fall CP
Date: 2019-09-10 11:00
Category: Misc
Tags: 2019FallCP
Slug: 2019-Fall-32-bit-Windows-2019
Author: yen
---

test111222

&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="leo.20200604214958.1">@language md
---
Title: 2018 Fall CP
Date: 2020-09-10 11:00
Category: Misc
Tags: 2018FallCP
Slug: 2018-Fall-32-bit-Windows-2018
Author: yen
---

test111

&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="leo.20200604215030.1"></t>
<t tx="leo.20200604215039.1"></t>
<t tx="leo.20200604222242.1">@language md
---
Title: 50833102-1
Date: 2019-09-10 11:00
Category: Misc
Tags: 50833102-1
Slug: 50833102-1
Author: Hu
---

test111222xxxx

&lt;!-- PELICAN_END_SUMMARY --&gt;
</t>
<t tx="leo.20200604222704.1">@language md
---
Title: 50833102-1
Date: 2019-09-10 11:00
Category: Misc
Tags: 50833102-1
Slug: 50833102-1
Author: Hu
---

test111222xxxxyyyyy

&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="leo.20200604222739.1"></t>
<t tx="leo.20200605043055.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    os.chdir("./../")
    server_address = ('localhost', 5443)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("5443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="leo.20200605043111.1">@language python
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os
# 配合使用 credential token
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request
argv=""
os.environ['TZ'] = 'Asia/Taipei'

import pickle
from google_auth_oauthlib.flow import InstalledAppFlow
 
 
SCOPES = ['https://www.googleapis.com/auth/blogger', ]
 
# we check if the file tBo store the credentials exists
if not os.path.exists('./../../blogger_token.dat'):
 
    flow = InstalledAppFlow.from_client_secrets_file('./../../client_secrets.json', SCOPES)
    credentials = flow.run_local_server()
 
    with open('./../../blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('./../../blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)

#with open('./../../blogger_credentials.dat', 'rb') as credentials_dat:
 #   credentials = pickle.load(credentials_dat)
#service,flags=sample_tools.init(
#    argv,'blogger','v3',__doc__,"./../../client_secrets.json",
#    scope="https://www.googleapis.com/auth/blogger")

service = build('blogger', 'v3', credentials=credentials)
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)
 
try:
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    blog_id = blogs["items"][0]["id"]
    # 設法取得原 post 的 id
    postid_outline = p.getLastChild()
    # 直接從標題取得 post 的 id 號碼
    post_id = postid_outline.h
    posts = service.posts()
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": title,
    "content": content
    }
    # need to save postId to outline head
    update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True)
    update_doc = update.execute()
    # 使用 credential token 後, 無需刪除 blogger.dat
    #os.remove("blogger.dat")
    g.es("post_id 為", post_id)
    g.es("已經將更新資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</t>
<t tx="leo.20200605133612.1">@language md
---
Title: 終於開始正題了
Date: 2020-06-05 01:39
Category: Misc
Tags: chapter1
Slug: 50833102-3
Author: Hu
---

    歷經了風雨和滄桑，我終於!終於能把文章推上Blogger了!!雖然我之前說過Blogger就只會放雜七雜八的東西，但既然現在要評分就要正經一點了ww

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others

 
</t>
<t tx="leo.20200605140138.1"></t>
<t tx="leo.20200605145658.1">@language md
---
Title:建立並且更改網誌
Date: 2020-06-05 02:50
Category: Misc
Tags: chapter2, wcmj, 網誌
Slug: 50833102-4
Author: Hu
---

1 建立一個倉儲(公開)

2 Setting中設為master branch

&lt;!-- PELICAN_END_SUMMARY --&gt;

@others</t>
<t tx="leo.20200605151650.1"></t>
<t tx="leo.20200605152629.1">@language md
---
Title: public key 和 private key
Date: 2020-06-05 03:28
Category: Misc
Tags: chapter3
Slug: 50833102-5
Author: Hu
---

目的是我們再用start.bat指令git push上github

1 使用putty 創建一個key (putty 可以在 Y 槽找到((Y槽要開啟wcmj2020tool的start.bat出現))

2 選擇public

3 儲存到Y槽的home

3 打開黑色指令視窗

4 打sh (對，只要sh)

5 打ssh-keygen -t rsa -b 4096 -c "密碼名"

6 接下來會問你要不要為它設保護，Enter就好

7 出現Enter file in which to save the key (/y/home/.ssh/id_rsa):

   打/y/keys/id_rsa

   y=y槽；home=檔案名；.ssh=檔案名 ；id_rsa=key的名字

8 這時key已經產生了，接著我們前往key的文件檔所在(接續上面/y/home/.ssh/id_rsa為例，就是.ssh)，把它丟進編輯器，再把產生的內容複製貼上到SSH keys(setting-&gt;ssh and gpg keys-&gt;new ssh key)

9 現在github已經得到ssh key 了

---現在要讓start.bat認得key---

10 開啟puttygen.exe，轉成ppk.格式，同樣儲存到home

11將start.bat丟到編輯器(那個白白的，把檔案丟進去會懺聲一對程式碼或亂碼的框框，我終於知道它的名字了)，插入

set GIT_HOME=%Disk%:\portablegit\bin\

set GIT_SSH=%Disk%:\putty\plink.exe

這兩行

12開啟puttygen.exe，選擇load，選擇id_rsa，選擇save private key，這些動作是將剛剛轉成ppk的id_rsa存檔

13開啟putty.exe，接著Connection-&gt;SSH-&gt;Auth

14確定home裡的.ssh目錄中的內容有無錯誤

15 最後再將 wcmj202的 .git目錄下的config檔案中的連線協定, 由https改為ssh連線ex:
 
(1)前往github的wcmj2020，點開那個能複製網址的綠色格子，再選取右上角的use ssh，再複製
(2)丟config到編輯器
(3)把url那段改掉，如下

16滿懷幸福，拖著疲憊的身軀，頂著沉重的腦袋，去睡吧!


&lt;!-- PELICAN_END_SUMMARY --&gt;



</t>
<t tx="leo.20200605164006.1">3 clone 網址到隨身碟
(https://127.0.0.1:9443這種，上一步產生的)

*網站有了，增加內容-------

4再資料夾(tmp)中建(wcmj2020)

5 git clone 這個網址

6 cd wcmj2020 

7 git submodule add https://github.com/mdecourse/cmsimde.git cmsimde

8到資料夾，找到up_dir，把內容Ctrl A到wcmj2020

---------(第9步起就是更改網頁)

9 python wsgi.py (啟動python之術!!!)

10然後複製因為前一步產生的新網址，Ctrl C到古歌看看

11修改後一定要記得generate page

(回到cmd)

12 cd..

13 git add . (add和點點中間一定要記得空白)

14 git commit -m "你要附註的東西"

15 git push

16 完成!!!!


</t>
<t tx="leo.20200605164404.1">   當然自由發會的部分我還是會盡其所能的不務正業啦 〳 ° ▾ ° 〵
    
    還有雖然吐槽過了，但滑鼠一點文字就不見真的很痛苦啊 இдஇ</t>
<t tx="leo.20200619231235.1">@language md
---
Title: leo
Date: 2020-06-20 07:13
Category: Misc
Tags: chapter4
Slug: 50833102-6
Author: Hu
---
*來源https://drive.google.com/file/d/1d_YpSrTdKLPKZjkHW2TNsbHRU1ePNRFl/view

這兩週的內容是連貫的，所以放一起講。

1 在指令欄進入wcmj2020，打leo

2 File &gt; Open-Outline &gt; config &gt;pelican.leo

3 Pelican設定 &gt;共用-第6和7行，改成:

                                       AUTHOR = '50833102'
                                       SITENAME = '50833102'

                       &gt;遠端-第17行，改成:

                                       SITEURL = 'https://50833102.github.io/wcmj2020/blog'

                       &gt;近端-不用改

4 @path markdown &gt; 2020 &gt; 2020 WCMJ 課程 &gt; @edit 20180910.md

5 複製前一篇文章(標準格式)，再作修改

6 點擊 local-blog 這個按鈕(如果要發佈到遠端就改成github-blog)

7 打開wcmj2020，找到http-server.py丟到編輯器，在編輯器上方的工具欄選擇Tool，再選擇Go，編輯器右邊頁面會顯示8444已啟動

8 成功的話再上傳到遠端


&lt;!-- PELICAN_END_SUMMARY --&gt;
</t>
<t tx="leo.20200619232357.1">@language md
---
Title: 憑證
Date: 2020-06-20 07:20
Category: Misc
Tags: chapter5
Slug: 50833102-7
Author: Hu
---
*來源https://drive.google.com/file/d/1I5fLwnRSeDPaSdXkrartxERICHKgmD20/view

今天要透過google金鑰讓Leo上的文章能直接上傳到blogger，簡單的想就是跟上週的目的差不多，增加local和github外多了一個新的blogger按鈕

1. 開啟網址console.developers.google.com

2. 點擊“憑證”

3. +建立憑證，再選取OAuth 用戶端 ID

4. 選擇”網頁應用程式”

5. 下載到tmp



憑證其實就是讓Blogger能認出你啦，下次再到近端，就可以讓Leo像W11-12一樣。直接幫我們推到自己的Blogger，至於Blogger的編輯在下一章



&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="leo.20200619233330.1"></t>
<t tx="leo.20200619233415.1">@language md
---
Title: 更改＆編輯Blogger
Date: 2020-06-20 07:34
Category: Misc
Tags: chapter6
Slug: 50833102-8
Author: Hu
---
接續上週，但有edit功能

blogger

https://2019wcm.blogspot.com/search/label/blogger

影片

https://drive.google.com/file/d/13KBfWIMULL9fAPw-T54cExMt9GUTW4XZ/view

1. 開啟編輯器預備

2. 打開黑黑的窗格(我還是習慣這樣叫ww)，git submodule:

pip install google-api-python-client

pip install oauth2client


3. 將下列程式碼打進編輯器:

'''
用來測試 Google Blogger Python API 新增文章程式
 
pip install google-api-python-client oauth2client
 
'''
 
import sys
from oauth2client import client
from googleapiclient import sample_tools
 
argv = ""
# 認證並建立服務
service, flags = sample_tools.init(
  argv, 'blogger', 'v3', __doc__, './client_secrets.json',
  scope='https://www.googleapis.com/auth/blogger')
 
try:
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    for blog in blogs['items']:
        print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 blog id
 
    body = {
    "kind": "blogger#post",
    "id": "123",
    "title": "透過 Python 程式新增網誌文章1",
    "content":"使用 Google Blogger API 可以利用程式新增網誌文章內容1"
    }
     
    insert = posts.insert(blogId='123', body=body)
    posts_doc = insert.execute()
    print(posts_doc)
     
    '''
    # 更新網誌文章時的 body
    body = {
    "kind": "blogger#post",
    "title": "透過 Python 程式修改網誌文章2",
    "content": "使用 Google Blogger API 可以利用程式修改網誌文章內容. http://mde.tw/cd2019"
    }
     
    update = posts.update(blogId="123", postId="456", body=body, publish=True)
    update_doc = update.execute()
    print(update_doc)
    '''
except(client.AccessTokenRefreshError):
    print("error")
    
    
4. 在tmp存檔，名稱後面加上.py讓它認得出這python

5. 將"blogid": "123",改成自己的Blogger ID

6. 將"postid": "456",改成那篇文章的ID (已經被上傳的文章才有)

7. 依照自己要上傳還是修改，使用 #上傳網誌文章時的 body  或  #更新網誌文章時的 body

"'三引號是多行標註的方法"'

8. './client_secret.json' ，client_secret.json就是上周做的憑證的檔名，./是指在同一個資料夾

8. Tools &gt; Go


&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="leo.20200620065914.1"></t>
<t tx="leo.20200620093305.1">@language md
---
Title: testtesttest
Date: 2020-06-20 09:30
Category: Misc
Tags: chapter9
Slug: 50833102-9
Author: Hu
---
dgsdhd???


&lt;!-- PELICAN_END_SUMMARY --&gt;</t>
<t tx="yen.20170108171605.1"></t>
<t tx="yen.20170108171605.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="yen.20170108171605.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="yen.20170108171733.1"></t>
<t tx="yen.20170108171733.2">@language python
import os

os.system("pelican markdown -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="yen.20170108171733.5"></t>
<t tx="yen.20170108171733.71"></t>
<t tx="yen.20170108171733.81"></t>
<t tx="yen.20170108171733.83">sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt

</t>
<t tx="yen.20170108171930.1">@language python
from markdown import markdown
from oauth2client import client
from googleapiclient import sample_tools
import os
# 配合使用 credential token
from googleapiclient.discovery import build
#from google_auth_oauthlib.flow import InstalledAppFlow
#from google.auth.transport.requests import Request
argv=""
os.environ['TZ'] = 'Asia/Taipei'

import pickle
from google_auth_oauthlib.flow import InstalledAppFlow
 
 
SCOPES = ['https://www.googleapis.com/auth/blogger', ]
 
# we check if the file tBo store the credentials exists
if not os.path.exists('./../../blogger_token.dat'):
 
    flow = InstalledAppFlow.from_client_secrets_file('./../../client_secrets.json', SCOPES)
    credentials = flow.run_local_server()
 
    with open('./../../blogger_token.dat', 'wb') as credentials_dat:
        pickle.dump(credentials, credentials_dat)
else:
    with open('./../../blogger_token.dat', 'rb') as credentials_dat:
        credentials = pickle.load(credentials_dat)
service = build('blogger', 'v3', credentials=credentials)
g.es(service)

#with open('./../../blogger_credentials.dat', 'rb') as credentials_dat:
 #   credentials = pickle.load(credentials_dat)
#service,flags=sample_tools.init(
#    argv,'blogger','v3',__doc__,"./../../client_secrets.json",
#    scope="https://www.googleapis.com/auth/blogger")

service = build('blogger', 'v3', credentials=credentials)
 
def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 ---
    # 用跳行符號分割
    data_list = data.split("\n")
    #第 2 行為 title
    title= data_list[1]
    #第 4 行為 category
    category = data_list[3]
    #第 5 行為 tags
    tags = data_list[4]
    # 有多項資料的 content 型別為數列
    # 再將第 9 行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[8:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 &lt;!--more--&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    #content = content.replace('~~~python', '[code lang="python"]')
    #content = content.replace('~~~', '[/code]')
    return title, category, tags, content
 
# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
# p.h 為 @clean filename.md
# 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案
md_filename = p.h.split(" ")[1]
with open(md_filename, 'r', encoding="utf-8") as content_file:
    md_content = content_file.read()
# title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
title_str, category_str, tags_str, content = get_cat_tag_content(md_content)
category = category_str.split(":")[1]
tags = tags_str.split(":")[1].split(",")
tags.append(category)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 將 markdown 格式 content 轉為 html
content = markdown(content)
# 以下處理 content 的 &lt;h2&gt; 標題
content = content.replace("&lt;h2&gt;", "&lt;h2&gt;&lt;font size='4'&gt;")
content = content.replace("&lt;/h2&gt;", "&lt;/font&gt;&lt;/h2&gt;")
# g.es(content)
 
try:
    
    users = service.users()
    # 取得使用者 profile 資料
    user = users.get(userId='self').execute()
    print('網誌名稱: %s' % user['displayName'])
    
    print('網誌名稱: %s' % user['displayName'])
    blogs = service.blogs()
    # 取得使用者所建立網誌名稱
    blogs = blogs.listByUser(userId='self').execute()
    # post_id is now blogs["items"][0]["id"]
    blog_id = blogs["items"][0]["id"]
    #for blog in blogs['items']:
        #print(blog['name'], blog['url'])
    posts = service.posts()
    # 新增網誌 post 時, 需要 post_id
    body = {
    "kind": "blogger#post",
    "id": blog_id,
    "title": title,
    # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容
    "content": content,
    "labels": tags
    }
    insert = posts.insert(blogId=blog_id, body=body)
    posts_doc = insert.execute()
    post_id = posts_doc["id"]
    #print(posts_doc)
    # 改用 credential token 後不會產生 blogger.dat
    #os.remove("blogger.dat")
    # 利用最後的 child 節點來儲存 post_id
    to_save_post_id = p.insertAsLastChild()   
    # 改為內文為空的節點, id 直接標在 head 標題 
    to_save_post_id.b = ""
    to_save_post_id.h = post_id
    # 因為新增節點, commander 必須 redraw
    c.redraw()
    g.es("post_id 為", post_id)
    g.es("已經將資料送往 Blogger!")
except(client.AccessTokenRefreshError):
    g.es("error")</t>
<t tx="yen.20170108171939.1">@language python
import os
import subprocess
import threading
import socket
import http.server, ssl

class HTTPServerV6(http.server.HTTPServer):
    address_family = socket.AF_INET6
  
def domake():
    # build directory
    os.chdir("./../")
    ipv6_address = '::1'
    server_address = (ipv6_address, 6443)
    #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print("6443 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="yen.20170224232341.1"></t>
<t tx="yen.20170224232341.2"></t>
</tnodes>
</leo_file>
